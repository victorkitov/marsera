# Программные реализации [[MARS]]
## py-earth

* Написан на *Python* и *Cython*.
* Интерфейс совместим с интерфейсом *scikit-learn*.
* Работает с массивами numpy.array и со всеми другими данными, которые можно преобразовать в numpy.array.

*Пример:*
![[Pasted image 20221031150620.png]]

![[Pasted image 20221031150530.png]]
***

### API
![[Pasted image 20221031151437.png]]
* *max_terms* - максимальное число базисных функций;
		default=min(2 * n + m // 10, 400)
* *max_degree* - максимальная степень множителей базисной функции;
		default=1
* *allow_missing* - обработка пропусков;
		*Estimating Functions of Mixed Ordinal and Categorical Variables Using Adaptive Splines, Jerome H.Friedman*
* *penalty* -  параметр сглаживания d в **GCV**  (чем больше, тем меньше узлов создаётся)
		  default=3;
![[Pasted image 20221031151947.png]]
* *thresh* - параметр, отвечающий за условия остановки
		либо **RSQ** > 1 - thresh, либо за одну итерацию **RSQ** увеличивается меньше, чем на thresh при прямом проходе
		**RSQ (коэффициент детерминации)** -  это доля дисперсии зависимой переменной, объясняемая рассматриваемой моделью зависимости, то есть объясняющими переменными.
		![[Pasted image 20221106230321.png]]
* *zero_tol* - опеределяет, с какой точностью считать 0;
* *smooth* - использовать ли сглаживание 
		default=False
		Вместо:
		![[Pasted image 20221105015210.png]]
		Использовать кубические усечённые сплайны с непрерывными 1ми производными, повторяющие вдали от излома сплайны срезки
		![[Pasted image 20221105015235.png]]
		![[Pasted image 20221105015437.png]]
* *feature_importance_type* - критерии важности признаков ('gcv', 'rss', ...);
* *use_fast* - использовать ли реализацию **Fast MARS**;
		default=False
		*Fast MARS, Jerome H.Friedman*
* *fast_K*, *fast_h* - параметры процедуры **Fast MARS**;
* *endspan_alpha* - вероятность  $\alpha$ сделать больше *endspan* отклонений в изложенном выше смысле;
		Для **ANOVA** разложения верна следующая форма записи:
		![[Pasted image 20221105152752.png]]
		![[Pasted image 20221105154909.png]]
		В (40) зависимость только от одной переменной. Если зафиксировать значения $\{a_i\}$, то (40) имеет общее решение:
		![[Pasted image 20221105155032.png]]
		Это может быть оценено с помощью взвешенного сглаживания. Если придать сглаживанию форму кусочно-линейного сплайнового приближения, то мы косвенно приходим к **MARS**.
		Если разрешать в качестве порога разбиения $t$ использовать любую точку из обучающих данных, то, в рамках задачи сглаживания, допускается сглаживание по одному наблюдению, что недопустимо, т.к. шум будет иметь сильное влияние. Поэтому хочется найти минимальный интервал (число $L(\alpha)$ данных между каждым узлом), устойчивый к шумам.
		![[Pasted image 20221106014639.png]]
		$Pr(L^*)$ - вероятность $\ge L^*$ успехов в $nN_m$ испытаниях Бернулли с $p = 0.5$,
		$\alpha$ - маленькое число (0.05 или 0.01),
		$N_m$ - кол-во наблюдений, для которых $B_m > 0$
		![[Pasted image 20221106013309.png]]
		![[Pasted image 20221106013323.png]]
* *endspan* - ручное задание интервала данных между и краем;
* *minspan_alpha* - вероятность  $\alpha$ сделать больше *minspan* отклонений в изложенном выше смысле;
* *minspan* - ручное задание интервала данных между соседними узлами внутри;
* *check_every* - только одно значение в данном интервале рассматривается в качестве нового узла. Если -1, то этот интервал равен *min_search_points*.
		default=-1
* *min_search_points* - используется для вычисления интервала;
		default=100
		$m$ - число объектов в данных (и только те, что попали в определённую "область")
		$check\_every = int(\frac{m}{min\_search\_points})$, если $m > min\_search\_points$
		$check\_every = 1$                                   , иначе
* *allow_linear* - допускать ли добавление "линейных" ф-ций (на текущем шаге не происходит домножение на **ReLU** с разными знаками, а происходит просто добавление одной линейной ф-ции)
		default=True
* *enable_pruning* - делать ли обратный проход;
* *verbose* - дополнительно выводимая информация;
***

#### Атрибуты

* *coef_* - веса несокращённых б.ф. $B_m$;
* *basis_* - представление конечного мн-ва б.ф.;
* *mse_* - (взвешанное) **MSE** итоговой модели;
* *rsq_* - (взвешанное) **RSQ** итоговой модели;
* *gcv_* - (взвешанное) **GCV** итоговой модели;
* *grsq_* - (взвешанная) оценка, аналогичная **RSQ**, построенная на **GCV** итоговой модели;
* *forward_pass_record_* - инф-я по прямому проходу;
* *pruning_pass_record_* - инф-я по обратному проходу;
* *xlabels_* - имена столбцов обучающих переменных;
* *allow_missing_* - какие переменные могут отсутствовать;
* *feature_importances_* - важность(и) всех объектов по одному из критериев;
***

#### Методы

Класс поддерживает все стандартные методы классов из *scikit-lean*:

Применение прохода вперёд и назад (обучение) или только что-то одно.
![[Pasted image 20221107182457.png]]
![[Pasted image 20221107182838.png]]
![[Pasted image 20221107183022.png]]
* *linvars* - указываются объекты, которые будут добавляться только линейно;

Просто переход в пр-во б.ф. будет полезен для последующего применения других методов.
![[Pasted image 20221107181731.png]]
![[Pasted image 20221107182206.png]]

Работа с параметрами.
![[Pasted image 20221107182421.png]]
![[Pasted image 20221107182439.png]]

Параметр сглаживания $d$.
![[Pasted image 20221107182858.png]]

Имеется возможность предсказать не только значения в передаваемых точках, но и значения первых производных в этих точках.
![[Pasted image 20221107182307.png]]
![[Pasted image 20221107182320.png]]

Описание модели и описание с выводом наиболее важных б.ф. в смысле *sort_by*.
![[Pasted image 20221107182355.png]]
![[Pasted image 20221107182405.png]]

Инф-я о проходе вперёд, назад и всё вместе.
![[Pasted image 20221107181642.png]]
![[Pasted image 20221107182130.png]]
![[Pasted image 20221107181705.png]]

Вычисляет обобщённый **RSQ**.
![[Pasted image 20221107183034.png]]

Вычисляет качество решения.
![[Pasted image 20221107183043.png]]

![[Pasted image 20221107182949.png]]